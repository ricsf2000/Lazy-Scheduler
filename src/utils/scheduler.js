export function generateDailySchedule(settings, tasks, availability = {}) {
  const getDayOfWeekKey = (dayOfWeek) => {
    const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday']
    return days[dayOfWeek]
  }
  
  // Filter and sort tasks by deadline
  const validTasks = tasks.filter(task => 
    task.name.trim() && task.hours && task.deadline
  ).map(task => ({
    ...task,
    deadline: new Date(task.deadline),
    remainingHours: task.hours
  })).sort((a, b) => a.deadline - b.deadline)

  if (validTasks.length === 0) return { schedule: {}, errors: [] }

  const schedule = {}
  const errors = []
  const today = new Date()
  
  // Find the furthest deadline to determine how far to look ahead
  const furthestDeadline = validTasks.length > 0 
    ? Math.max(...validTasks.map(task => task.deadline.getTime()))
    : today.getTime()
  
  const daysToLookAhead = Math.max(1, Math.ceil((furthestDeadline - today.getTime()) / (1000 * 60 * 60 * 24)) + 1)
  
  // Create a list of available days with their hours
  const availableDays = []
  for (let i = 0; i < daysToLookAhead; i++) {
    const date = new Date(today)
    date.setDate(today.getDate() + i)
    const dateStr = date.toISOString().split('T')[0]
    const dayOfWeek = date.getDay()
    const dayKey = getDayOfWeekKey(dayOfWeek)
    
    // Use custom availability if set, otherwise use default for that day
    const customHours = availability[dateStr]
    const defaultHours = settings[dayKey]
    const dayHours = customHours !== undefined ? customHours : defaultHours
    
    availableDays.push({
      date: dateStr,
      availableHours: dayHours,
      scheduledHours: 0,
      tasks: []
    })
  }

  // Separate exams and regular tasks
  const exams = validTasks.filter(task => task.type === 'exam')
  const assignments = validTasks.filter(task => task.type !== 'exam')
  
  // Function to schedule a single task
  const scheduleTask = (task, iterateBackward = false) => {
    let remainingHours = task.remainingHours
    
    // Find days before the deadline
    const taskDeadline = task.deadline
    const availableForTask = availableDays.filter(day => 
      new Date(day.date) <= taskDeadline
    )

    // Exclude the deadline day for both exams and assignments
    let daysToUse = availableForTask.slice(0, -1)
    // If that leaves no days, fall back to all available days
    if (daysToUse.length === 0) {
      daysToUse = availableForTask
    }

    // Choose iteration order based on task type
    const daysToIterate = iterateBackward ? [...daysToUse].reverse() : daysToUse

    // Distribute task hours across selected days
    for (const day of daysToIterate) {
      if (remainingHours <= 0) break
      
      const freeHours = day.availableHours - day.scheduledHours
      if (freeHours <= 0) continue
      
      const hoursToSchedule = Math.min(remainingHours, freeHours)
      
      if (hoursToSchedule > 0) {
        day.tasks.push({
          name: task.name,
          hours: hoursToSchedule,
          totalHours: task.hours,
          deadline: task.deadline,
          type: task.type
        })
        
        day.scheduledHours += hoursToSchedule
        remainingHours -= hoursToSchedule
      }
    }
    
    // If we couldn't schedule all hours, track the error
    if (remainingHours > 0) {
      errors.push({
        task: task.name,
        missingHours: remainingHours,
        totalHours: task.hours,
        deadline: task.deadline
      })
    }
  }

  // First pass: Schedule all exams (backward iteration for optimal timing)
  exams.forEach(task => scheduleTask(task, true))
  
  // Second pass: Schedule all assignments (forward iteration)
  assignments.forEach(task => scheduleTask(task, false))

  // Convert to schedule object with only days that have tasks
  availableDays.forEach(day => {
    if (day.tasks.length > 0) {
      schedule[day.date] = day.tasks
    }
  })

  return { schedule, errors }
}

export function exportToCalendar(schedule) {
  let icalContent = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//lock-in.io//Study Session Planner//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH'
  ]
  
  let eventIndex = 0
  
  // Iterate through each date in the schedule
  Object.entries(schedule).forEach(([dateStr, tasks]) => {
    tasks.forEach(task => {
      const uid = `lockin-${Date.now()}-${eventIndex}@lock-in.io`
      const dtstart = dateStr.replace(/-/g, '') // Format: YYYYMMDD for all-day event
      
      // Create all-day event with hours in the name
      const taskName = `${task.name} (${task.hours}h)`
      const description = `${task.type === 'exam' ? 'Exam Study' : 'Assignment Work'} - ${task.hours} hours planned - Generated by lock-in.io`
      
      icalContent.push(
        'BEGIN:VEVENT',
        `UID:${uid}`,
        `DTSTART;VALUE=DATE:${dtstart}`,
        `SUMMARY:${taskName}`,
        `DESCRIPTION:${description}`,
        'STATUS:CONFIRMED',
        'TRANSP:TRANSPARENT', // Transparent so it doesn't block time
        'END:VEVENT'
      )
      
      eventIndex++
    })
  })
  
  icalContent.push('END:VCALENDAR')
  
  const icalString = icalContent.join('\r\n')
  
  // Create and download the file
  const blob = new Blob([icalString], { type: 'text/calendar;charset=utf-8' })
  const url = URL.createObjectURL(blob)
  
  const link = document.createElement('a')
  link.href = url
  link.download = 'study-schedule.ics'
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  
  URL.revokeObjectURL(url)
}

// Helper functions
function minutesToTime(minutes) {
  const hours = Math.floor(minutes / 60)
  const mins = minutes % 60
  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`
}

function formatDateForICS(date) {
  return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
}